<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Dossi Dashboard</title>
  
  <!-- Fonts & Icons -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Plus+Jakarta+Sans:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/@phosphor-icons/web"></script>

  <style>
    :root {
      /* Colors from Pitch Deck */
      --bg-paper: #F5F5F8;
      --bg-card: #FFFFFF;
      --text-dark: #1a1a1a;
      --text-muted: #8E8E93;
      --accent: #737BF2;
      
      --color-black: #000000;
      --color-high: #FFC107;   
      --color-low: #EF4444;    
      
      /* Pitch Deck Font Stacks */
      --font-body: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      --font-heading: 'Plus Jakarta Sans', -apple-system, BlinkMacSystemFont, sans-serif;
    }

    body {
      margin: 0;
      padding: 0;
      background-color: #E8E8ED; 
      font-family: var(--font-body);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      color: var(--text-dark);
      overflow: hidden;
    }

    .dashboard-card {
      width: 1000px;
      height: 700px;
      max-width: 95vw;
      max-height: 95vh;
      background: var(--bg-paper);
      border-radius: 24px;
      box-shadow: 0 8px 60px rgba(0, 0, 0, 0.15), 0 2px 8px rgba(0, 0, 0, 0.08);
      padding: 48px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 32px;
      position: relative;
    }

    .top-image-container {
      width: 100%;
      display: flex;
      justify-content: flex-start;
      margin-bottom: 8px;
    }
    .logo-img {
      height: 36px; 
      width: auto;
      display: block;
      opacity: 0.9;
    }

    .header-row {
      display: flex;
      justify-content: space-between;
      align-items: flex-end; 
      padding: 0 4px;
    }

    .glucose-display {
      display: flex;
      align-items: flex-end; 
      gap: 20px;
    }

    .glucose-group {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      line-height: 1;
    }

    .glucose-value {
      font-family: var(--font-heading);
      font-size: 110px; 
      font-weight: 800;
      color: var(--color-black);
      letter-spacing: -4px;
      font-variant-numeric: tabular-nums;
      margin-bottom: -10px; 
    }

    .glucose-unit {
      font-size: 20px;
      font-weight: 600;
      color: var(--text-muted);
      margin-left: 8px;
      margin-top: 12px; 
    }

    .trend-arrow {
      font-size: 64px;
      color: var(--text-muted);
      font-weight: 700;
      margin-bottom: 12px; 
    }

    .right-header-group {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 20px;
      padding-bottom: 8px; 
    }

    .current-time {
      font-family: var(--font-heading);
      font-size: 36px;
      font-weight: 700;
      color: var(--text-dark);
      font-variant-numeric: tabular-nums;
    }

    .chart-wrapper {
      flex: 1;
      position: relative;
      width: 100%;
      min-height: 0;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>

  <div class="dashboard-card">
    <div class="top-image-container">
      <img src="dossi-wordmark.png" alt="dossi" class="logo-img">
    </div>

    <div class="header-row">
      <div class="glucose-display">
        <div class="glucose-group">
          <div class="glucose-value" id="bgValue">--</div>
          <div class="glucose-unit">mg/dL</div>
        </div>
        <div class="trend-arrow" id="trendArrow">--</div>
      </div>
      
      <div class="right-header-group">
        <div class="time-container">
          <div class="current-time" id="timeValue">--:--</div>
        </div>
      </div>
    </div>

    <div class="chart-wrapper">
      <canvas id="cgmChart"></canvas>
    </div>
  </div>

  <script>
    const CONFIG = {
      minutesPerFrame: 0.5, 
      hoursVisible: 4,
      colors: {
        bg: '#F5F5F8',
        text: '#1a1a1a',     
        dotInRange: '#000000', 
        high: '#FFC107',     
        low: '#EF4444',      
        targetBand: '#E5E5EA',
        lineHigh: '#FFC107',   
        lineLow: '#EF4444',    
        predictionLine: '#737BF2',
        eventFill: 'rgba(115, 123, 242, 0.1)', 
        eventBorder: 'rgba(115, 123, 242, 0.4)',                 
        eventText: '#5B63E0'                    
      },
      baseGlucose: 90, 
      events: [
        { start: 23, end: 7, label: 'Sleep' },
        { start: 7.0, end: 9.0, label: 'Breakfast' }, 
        { start: 11.5, end: 14.0, label: 'Lunch' },   
        { start: 17.0, end: 18.5, label: 'Exercise' },
        { start: 19.0, end: 21.0, label: 'Dinner' }
      ],
      meals: [
        { time: 8.0, height: 210, width: 1.2 }, 
        { time: 12.5, height: 160, width: 2.0 }, 
        { time: 20.0, height: 180, width: 2.5 }  
      ]
    };

    function gaussian(x, peakTime, height, width) {
      let dx = x - peakTime;
      if (dx > 12) dx -= 24;
      if (dx < -12) dx += 24;
      return height * Math.exp(-(dx * dx) / (2 * (width * width / 4)));
    }

    function getGlucoseAtTime(t) {
      const tMod = ((t % 24) + 24) % 24;
      const circadian = Math.sin((tMod - 4) * (Math.PI / 12)) * 10; 
      let mealImpact = 0;
      CONFIG.meals.forEach(m => mealImpact += gaussian(tMod, m.time, m.height, m.width));
      const exerciseImpact = -gaussian(tMod, 18.0, 75, 0.7); 
      const noise = Math.sin(tMod * 25) * 4 + Math.sin(tMod * 40) * 2;
      return CONFIG.baseGlucose + circadian + mealImpact + exerciseImpact + noise;
    }

    // Helper to get glucose without high-freq noise for smoother labels
    function getSmoothGlucoseAtTime(t) {
      const tMod = ((t % 24) + 24) % 24;
      const circadian = Math.sin((tMod - 4) * (Math.PI / 12)) * 10; 
      let mealImpact = 0;
      CONFIG.meals.forEach(m => mealImpact += gaussian(tMod, m.time, m.height, m.width));
      const exerciseImpact = -gaussian(tMod, 18.0, 75, 0.7); 
      const smoothNoise = Math.sin(tMod * 25) * 0.5; 
      return CONFIG.baseGlucose + circadian + mealImpact + exerciseImpact + smoothNoise;
    }

    function getPredictionAtTime(t) {
      const tMod = ((t % 24) + 24) % 24;
      const circadian = Math.sin((tMod - 4) * (Math.PI / 12)) * 8; 
      let mealImpact = 0;
      CONFIG.meals.forEach(m => { mealImpact += gaussian(tMod, m.time, m.height * 0.4, m.width); });
      const exerciseImpact = -gaussian(tMod, 18.0, 20, 1.5);
      return CONFIG.baseGlucose + circadian + mealImpact + exerciseImpact - 5;
    }

    function getTrendArrow(t) {
      const current = getGlucoseAtTime(t);
      const prev = getGlucoseAtTime(t - (10/60)); 
      const delta = current - prev;
      if (delta > 8) return '↑'; 
      if (delta > 3) return '↗';
      if (delta < -8) return '↓'; 
      if (delta < -3) return '↘';
      return '→';
    }

    const canvas = document.getElementById('cgmChart');
    const ctx = canvas.getContext('2d');
    const elBgValue = document.getElementById('bgValue');
    const elTrend = document.getElementById('trendArrow');
    const elTime = document.getElementById('timeValue');

    let currentTime = 8.0;
    
    // Smoothing variables for labels
    let smoothLabelG = 0;
    let smoothLabelD = 0;
    let isFirstFrame = true;

    const Y_MAX = 350;
    const Y_MIN = 40; 
    function mapY(val) {
      return (canvas.height / window.devicePixelRatio) - ((val - Y_MIN) / (Y_MAX - Y_MIN)) * (canvas.height / window.devicePixelRatio);
    }

    let width, height; 
    function resize() {
      const parent = canvas.parentElement;
      const dpr = window.devicePixelRatio || 1;
      const rect = parent.getBoundingClientRect();
      width = rect.width;
      height = rect.height;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.resetTransform(); 
      ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', resize);
    resize();

    function roundRectPath(ctx, x, y, w, h, radius) {
      if (w < 2 * radius) radius = w / 2;
      if (h < 2 * radius) radius = h / 2;
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.arcTo(x + w, y, x + w, y + h, radius);
      ctx.arcTo(x + w, y + h, x, y + h, radius);
      ctx.arcTo(x, y + h, x, y, radius);
      ctx.arcTo(x, y, x + w, y, radius);
      ctx.closePath();
    }

    function draw() {
      currentTime += (CONFIG.minutesPerFrame / 60);
      if (currentTime > 100) currentTime %= 24;
      ctx.clearRect(0, 0, width, height);
      const GRAPH_RIGHT_BOUNDARY = width - 80;

      // Target Range Gray Block (70-180)
      const y180 = mapY(180);
      const y70 = mapY(70); 
      ctx.fillStyle = CONFIG.colors.targetBand;
      ctx.fillRect(0, y180, width, y70 - y180);

      // Hyper Line (Yellow @ 250)
      const y250 = mapY(250);
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(0, y250); ctx.lineTo(width, y250); 
      ctx.strokeStyle = CONFIG.colors.lineHigh; ctx.stroke();

      // Hypo Line (Red @ 55)
      const y55 = mapY(55);
      ctx.beginPath(); ctx.moveTo(0, y55); ctx.lineTo(width, y55);
      ctx.strokeStyle = CONFIG.colors.lineLow; ctx.stroke();

      const viewEnd = currentTime;
      const viewStart = viewEnd - CONFIG.hoursVisible;

      // Activity Blocks
      CONFIG.events.forEach(ev => {
        if (ev.start > ev.end) {
          [-24, 0, 24].forEach(offset => {
             drawEventRect(ev, viewStart, viewEnd, ev.start + offset, ev.end + offset + 24, GRAPH_RIGHT_BOUNDARY);
          });
        } else {
          [-24, 0, 24].forEach(offset => {
            drawEventRect(ev, viewStart, viewEnd, ev.start + offset, ev.end + offset, GRAPH_RIGHT_BOUNDARY);
          });
        }
      });

      // Dossi Prediction Line
      ctx.beginPath();
      for (let x = 0; x <= GRAPH_RIGHT_BOUNDARY; x += 2) {
        const t = viewStart + (x / GRAPH_RIGHT_BOUNDARY) * CONFIG.hoursVisible;
        const val = getPredictionAtTime(t);
        const y = mapY(val);
        if (x===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = CONFIG.colors.predictionLine;
      ctx.lineWidth = 3; 
      ctx.lineCap = 'round';
      ctx.stroke();
      
      // Glucose Dots
      const hoursPerDot = 5 / 60;
      let tLoop = Math.floor(viewStart / hoursPerDot) * hoursPerDot;
      while (tLoop <= viewEnd) {
        if (tLoop >= viewStart) {
          const glucose = getGlucoseAtTime(tLoop);
          const x = ((tLoop - viewStart) / CONFIG.hoursVisible) * GRAPH_RIGHT_BOUNDARY;
          const y = mapY(glucose);
          if (x <= GRAPH_RIGHT_BOUNDARY) {
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            if (glucose > 180) ctx.fillStyle = CONFIG.colors.high;
            else if (glucose < 70) ctx.fillStyle = CONFIG.colors.low;
            else ctx.fillStyle = CONFIG.colors.dotInRange; 
            ctx.fill();
          }
        }
        tLoop += hoursPerDot;
      }
      
      // --- SMOOTH LABEL LOGIC ---
      const targetG = mapY(getSmoothGlucoseAtTime(viewEnd));
      const targetD = mapY(getPredictionAtTime(viewEnd));
      
      if (isFirstFrame) {
        smoothLabelG = targetG;
        smoothLabelD = targetD;
        isFirstFrame = false;
      } else {
        smoothLabelG += (targetG - smoothLabelG) * 0.05;
        smoothLabelD += (targetD - smoothLabelD) * 0.05;
      }
      
      let yG = smoothLabelG;
      let yD = smoothLabelD;
      
      const dist = Math.abs(yG - yD);
      const minDist = 16;
      if (dist < minDist) {
        const push = (minDist - dist) / 2;
        if (yG < yD) { yG -= push; yD += push; }
        else { yG += push; yD -= push; }
      }
      
      ctx.font = '700 11px Inter'; 
      ctx.textAlign = 'left';
      
      ctx.fillStyle = CONFIG.colors.text;
      ctx.fillText('GLUCOSE', GRAPH_RIGHT_BOUNDARY + 8, yG + 4);
      
      ctx.fillStyle = CONFIG.colors.predictionLine;
      ctx.fillText('WITH DOSSI', GRAPH_RIGHT_BOUNDARY + 8, yD + 4);

      updateDOM(currentTime);
      requestAnimationFrame(draw);
    }

    function drawEventRect(ev, viewStart, viewEnd, evStartAbs, evEndAbs, graphRight) {
        const drawStart = Math.max(viewStart, evStartAbs);
        const drawEnd = Math.min(viewEnd, evEndAbs);
        if (drawStart < drawEnd) {
          const x1 = ((drawStart - viewStart) / CONFIG.hoursVisible) * graphRight;
          const x2 = ((drawEnd - viewStart) / CONFIG.hoursVisible) * graphRight;
          ctx.save();
          ctx.beginPath();
          ctx.rect(0, 0, graphRight, canvas.height); 
          ctx.clip();
          
          roundRectPath(ctx, x1, 0, x2 - x1, canvas.height, 16);
          ctx.fillStyle = CONFIG.colors.eventFill;
          ctx.fill();

          const centerX = x1 + ((x2 - x1) / 2);
          if (x2 > 0 && x1 < graphRight) {
            ctx.fillStyle = CONFIG.colors.eventText;
            ctx.font = '700 13px Inter'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top'; 
            ctx.fillText(ev.label.toUpperCase(), centerX, 12);
          }
          ctx.restore();
        }
    }

    function updateDOM(t) {
      const snapMinutes = 60; 
      let tMod = ((t % 24) + 24) % 24;
      const totalMinutes = Math.floor(tMod * 60);
      const roundedMinutes = Math.floor(totalMinutes / snapMinutes) * snapMinutes;
      const displayTime = roundedMinutes / 60;
      const val = Math.round(getGlucoseAtTime(displayTime));
      elBgValue.innerText = val < 40 ? "LOW" : val;
      elTrend.innerText = getTrendArrow(displayTime);
      if (val > 180) {
        elBgValue.style.color = CONFIG.colors.high; elTrend.style.color = CONFIG.colors.high;
      } else if (val < 70) {
        elBgValue.style.color = CONFIG.colors.low; elTrend.style.color = CONFIG.colors.low;
      } else {
        elBgValue.style.color = CONFIG.colors.text; elTrend.style.color = CONFIG.colors.text; 
      }
      const h = Math.floor(roundedMinutes / 60);
      const m = roundedMinutes % 60;
      const ampm = h >= 12 ? 'PM' : 'AM';
      const h12 = h % 12 || 12; 
      const pad = n => n.toString().padStart(2, '0');
      elTime.innerText = `${h12}:${pad(m)} ${ampm}`;
    }

    requestAnimationFrame(draw);
  </script>
</body>
</html>
